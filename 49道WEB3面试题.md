[TOC]

# 49个区块链问题

数量掌握49个区块链问题以后，就可以去从事区块链相关的工作了。

## 一、关键字virtual的作用

### （一）virtual关键字是什么

在`solidity 1.6`中，引入了关键字`abstract`、`virtual`和`override`，这三个关键字用来实现solidity的继承机制。

父合约中需要被重写的方法需要使用关键字`virtual`，子合约中重写函数中使用关键字`override`。在`Java`语言中，使用的是`extends`。

### （三）virtual关键字的使用案例

1. 继承并重写父合约中的普通方法

在下面的案例中，基类为`Person`合约，默认初始化`gender`为`unknown`。其中有`changeGender`的函数，这里声明为`virtual`，就是允许子类继承后可以进行修改。

然后是一个`Man`合约，它的构造函数后面的`Person()`表示的在执行`Man`合约的构造函数前，执行父合约`Person`的构造函数。注意，`Man`合约重写了父合约中的`changeGender`方法，重写的方法需要被标注为`override`。

然后是一个`Trans`合约，这个合约表示的是变性人，它首先继承了男人的所有属性和方法，但是重写了男人的`changeGender`的方法。

```solidity
pragma solidity ^0.8.0;

contract Person {
    string public gender;

    constructor() {
        gender = "unknown";
    }

    function changeGender() public virtual {}
}

contract Man is Person {
    string public name;
    constructor(string memory _name) Person() {
        name = _name;
        changeGender();
    }

    function changeGender() public virtual override {
        gender = "male";
    }
}

contract Trans is Man {
    constructor(string memory _name) Man(_name) {
        changeGender();
    }

    function changeGender() public override {
        gender = "female";
    }
}
```

2. 在子合约中调用父合约的方法

下面的基类合约是`Parent`，它实现了一个`test`方法，其中在开始和结尾配置了两个`hooks`方法。

```solidity
contract Parent {
    
    constructor () {
    }

    event ShowSomething(string indexed, int);

    function test() public {
        _begin();
        emit ShowSomething("ss", 2);
        _end();
    }
    
    // hook
    function _begin() internal virtual {
    }

    function _end() internal virtual {
    }
}
```

首先，我们可以通过`virtual`和`override`的方法来重写父类中的`hooks`方法。

```solidity
contract Child is Parent {
    constructor () {
    }

    event Begin(string indexed);
    event End(string indexed);

    // 实现父类Test中的hooks
    function _begin() internal override {
        Test._begin();
        emit Begin("rr");
    }

    // 实现父类Test中的hooks
    function _end() internal override {
        Test._end();
        emit End("tt");
    }
}
```

注意到，其中有两个地方使用了`Test._begin()`和`Test._end()`，这两句话的意思就是在执行子类重写的方法前，首先执行父类中的方法。

除了上述方式（`合约名.方法名`），我们还可以直接使用`super.方法名`这种方式，`super`会自动寻找父合约中的方法来进行调用。

上述两种方式，在单继承的时候，没有什么区别，但是在多重继承的时候，使用`合约名.方法名`的方式，只会执行指定合约的方法。但是使用`super.方法名`的时候，如果多个合约都重写了，则会依次执行。

下面分别实现了两个基类A和B，他们都提供了一个可以继承的`foo()`方法，然后使用合约C进行继承并重写。

基类合约A：

```solidity
contract A {
	function foo() public virtual {
	
	}
}
```

基类合约B:

```solidity
contract B {
	function foo() public virtual {
	}
}
```

继承合约C：

```solidity
contract C is A, B {
	function foo() public override (A, B) {
		super.foo();
	}
}
```

如果使用`A.foo()`或者`B.foo()`，那么只会执行A合约或者B合约中的方法，但是使用`super.foo()`，则会根据合约定义时，继承的顺序来选择到底执行哪个父合约中的方法。

比如说，我们合约是下面这样写的话，就执行B合约中的`foo`方法：

```solidity
contract C is A, B {
	function foo() public override (A, B) {
		super.foo();
	}
}
```

如果向下面这样写的话，就执行A合约中的`foo`方法：

```solidity
contract C is B, A {
	function foo() public override (A, B) {
		super.foo();
	}
}
```

## 二、事件

### （一）事件是什么

区块链包含交易树和收据树，交易树保存区块链发起交易的信息，收据树保存交易执行的日志记录，而日志记录一般都是因为触发事件而产生的。

事件定义的方式：

```solidity
event EventName(address bidder, uint amount);
```

事件调用的方式，通过下面这个代码就可以将交易发起者和交易的金额，放置在日志中了。

```solidity
emit EventName(msg.sender, msg.value);
```

### （二）事件的使用案例

1. 打印日志

由于EVM中没有提供`console.log`这类的基础实现，所以，因此，可以借助EVM的事件机制来实现打印日志。

工具类，参考下面这段代码：

```solidity
pragma solidity ^0.8.0;

// 通过log函数重载，对不同类型的变量trigger不同的event，实现solidity打印效果，使用方法为：log(string name, var value)
contract Console {
    event LogUint(string, uint);
    function log(string memory s , uint  x) internal {
    	emit LogUint(s, x);
    }
 
    event LogInt(string, int);
    function log(string memory s , int x) internal {
    	emit LogInt(s, x);
    }
 
    event LogBytes(string, bytes);
    function log(string memory s , bytes memory  x) internal {
    	emit LogBytes(s, x);
    }
 
    event LogBytes32(string, bytes32);
    function log(string memory s , bytes32 x) internal {
    	emit LogBytes32(s, x);
    }
 
    event LogAddress(string , address);
    function log(string memory s  , address  x) internal {
    	emit LogAddress(s, x);
    }
 
    event LogBool(string, bool);
    function log(string memory s , bool x) internal {
        emit LogBool(s, x);
    }
}
```

> 对于事件，我们采用大驼峰的命名方法，对于方法我们采用小驼峰的命名方法。上面的代码通过重载的方式，实现了一种方法，答应多种类型变量的日志。
>
> 其中，`s`表示的是变量名称，`x`表示的是具体的值。

比如，我们有一个基础合约`A`。如下所示，只要在脚本一开头，引入`Console.sol`，也就是上面的代码即可。

```solidity
pragma solidity ^0.8.0;
 
import "./Console.sol";

contract A is Console {
	function foo() public virtual {
    	bool flag = false;
    	log("flag = ", flag);
	}
}
```

## 三、calldata、memory、storage

### （一）calldata、memory、storage是什么

solidity中数据位置类型主要有三种，不同的位置类型具有不同的生命周期和访问特性。

> 针对引用类型，就必须始终显式的提供存储该类型数据的区域。引用类型包括结构、数组和映射，后面会介绍到。

**（1）memory**

`memory`有以下三种特性：

- 生命周期同函数生命周期，在`memory`中保存的变量的生命周期依赖于定义他们的函数，但凡函数被执行完毕，这些变量的生命也就终结了。当函数运行结束时，所有的变量都会被丢弃，到时候，没有任何方法可以访问到这些变量。

- 只能在函数内部访问，这些变量仅仅被函数内部访问到，他们存在的意义就是协助函数运算。

- 凡是被定义在function中的变量，都被保存在了`memory`中。

**（2）calldata**

calldata也是一个临时变量，他和`memory`定义的变量具有相同的性质。

- 生命周期同函数生命周期。

- 只能在函数内部访问。

- calldata修饰的变量**不可以被修改**。

`calldata`是一个不可以修改的、不可以被持久化的存储区域，专门用来存储函数参数。

当然，在`calldata`出现的位置都可以替换为`memory`，但是还是要选择尽量使用`calldata`，因为`calldata`可以避免复制和避免修改，这不仅可以节省gas费用，还在一定程度上保证了安全。

**（3）storage**

`storage`有三种特性：

- 生存期同区块链，`storage`的生存期就是合约的生存期，由于区块链是永远不会消失的，所以其生存期可以说是"永恒的"。

- 可以被合约中的任何函数访问。

- 定义在合约中的变量，默认的存储位置就是`storage`.

### （二）calldata、memory、storage的使用案例

1. 关于赋值逻辑

数据位置不仅与数据存储的位置有关系，他们相互之间赋值的时候，也会出现一些差别。这种差别在逻辑上影响不是非常大，但是会影响gas费用的消耗。

- 从`memory`赋值到`memory`，从`storage`到`storage`，都仅需要复制引用。

- 从`storage`赋值到`memory`或者从`storage`到`memory`，都需要复制内容。

下面是一个例子：

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.5.0 <0.9.0;

contract C {
    // x 的数据位置是storage
    // 合约中状态变量的数据位置都是storage，因此可以被忽略。
    uint[] x;

    // uint[]属于引用类型，需要明确给出数据位置，在这里是memory
    function f(uint[] memory memoryArray) public {
    	// 从memory到storage，需要整体复制
        x = memoryArray;
        
        // 从local storage到storage，只需要复制引用
        uint[] storage y = x;
        
        // 进行下面的操作时，操作y会影响x，操作x会影响y
        y[7]; // 返回第8个元素
        y.pop(); // 弹出元素
        delete x; // 清空数组
        
        // 进行下面操作时，都不合法
        y = memoryArray; // 因为需要创建一个新的临时的storage的区域，但是storage都是被静态分配的，不可能在代码运行的过程中申请到storage空间，因为区块链的机制是在一开始就分配好了合约的空间的。
        
        delete y; // delete 含义针对合约中的引用，就是清空数组，针对通过赋值产生的引用，只能是重置为空指针
        g(x); // 只会复制引用
        h(x); // 进行一次复制
    }

    function g(uint[] storage) internal pure {}
    function h(uint[] memory) public pure {}
}
```

上面的代码中，有两点比较重要：

1. 合约中定义的`storage`引用，当他们引用了合约的状态变量以后，只能对其进行`pop`、`push`和索引访问等操作，也不能直接`delete`。

2. 合约中定义的`storage`引用，不可以直接将`memory`复制给他们。

### 7.memory、storage和calldata

**(2)变量类型和变量作用域**

不同类型和作用域的变量，需要绑定不同的位置类型。

必须明确的是，每个被声明的变量都必须有一个存储类型与之对应。

只不过有些时候，定义某些变量时存在默认的位置类型。

因此首先明确以下变量类型和变量作用域。

1. 两种变量类型

- 引用类型

数组（包含字符串strings或字节类型bytes），映射（mapping）和结构体（structure）。

- 数值类型

除了引用类型，其余的类型都是数值类型。

2. 两种作用域类型

- 本地变量

在函数中定义的变量。

- 全局变量

或者说是状态变量，这些变量在函数体外定义。

**(3)绑定位置类型到变量**

1. **耗费gas值有大到小，`storage`>`memory`>`calldata`，因此在编程中，要时刻注意节约`gas`费用，在不影响程序逻辑的情况下，使用消耗更低的位置类型来绑定变量。**

2. 全局变量默认为`storage`类型，且不允许定义为其他类型。

3. 函数参数（包含返回内容）必须是`memory`或者是`calldata`类型。

4. 如果某个变量为本地变量，且为值类型，则其默认位置类型为`memory`类型，且不允许定义为其他类型。

5. 如果某个变量为本地变量，且为引用类型，其没有默认位置，必须手动定义，否则会报如下错误。

> TypeError: Data location must be "storage"， "memory" or "calldata" for variable， but none was given。

**(4)注意事项**

1. 值类型的相互之间的赋值，赋值就相当于拷贝。

2. 引用类型相互之间的赋值，位置类型不同将触发不同的行为：

- 如果是`storage`->`storage`或者是`memory(calldata)`<->`memory(calldata)`的话，相当于引用传递。

- 如果是`storage`<->`memory(calldata)`的时候，相当于整体值拷贝。

下面这段代码演示的是值传递：

```solidity
contract Ballot {
    uint[] ages;
    function vote() public returns(uint[] memory) {
        ages = new uint[](2); // storage
        ages[0] = 2;
        ages[1] = 3;
    
        uint[] memory newages = ages; // from storage to local storage
        newages[0] = 7;
        return ages; //returns (2，3)
    }
}
```

下面这段代码演示的是引用传递：

```solidity
contract Ballot {
    uint[] ages;
    function vote() public returns(uint[] memory) {
        ages = new uint[](2); // storage
        ages[0] = 2;
        ages[1] = 3;
    
        uint[] memory newages = ages; // from storage to local storage
        newages[0] = 7;
        return ages; //returns (7，3)
    }
}
```

## 四、结构、数组和映射

### （一）结构

结构，和C语言中的结构是类似的，和Java中的类也是类似的，就是应该包裹一系列相关的变量的。

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.6.0 <0.9.0;

// 定义一种新的类型包含两个字段，定义在合约外的结构可以被多个合约共享
struct Funder {
    address addr;
    uint amount;
}

contract CrowdFunding {
	// 定义在内部的结构智能被合约内部的变量，函数和以及继承的合约看到
    struct Campaign {
        address payable beneficiary;
        uint fundingGoal;
        uint numFunders;
        uint amount;
        mapping (uint => Funder) funders;
    }

    uint numCampaigns;
    mapping (uint => Campaign) campaigns;

    function newCampaign(address payable beneficiary, uint goal) public returns (uint campaignID) {
        campaignID = numCampaigns++; // campaignID is return variable
        // We cannot use "campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0)"
        // because the right hand side creates a memory-struct "Campaign" that contains a mapping.
        Campaign storage c = campaigns[campaignID];
        c.beneficiary = beneficiary;
        c.fundingGoal = goal;
    }

    function contribute(uint campaignID) public payable {
        Campaign storage c = campaigns[campaignID];
        // Creates a new temporary memory struct, initialised with the given values
        // and copies it over to storage.
        // Note that you can also use Funder(msg.sender, msg.value) to initialise.
        c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value});
        c.amount += msg.value;
    }

    function checkGoalReached(uint campaignID) public returns (bool reached) {
        Campaign storage c = campaigns[campaignID];
        if (c.amount < c.fundingGoal)
            return false;
        uint amount = c.amount;
        c.amount = 0;
        c.beneficiary.transfer(amount);
        return true;
    }
}
```

`CrowdFunding`表示的是一个众筹，`Campaign`表示的是运动，`Funder`表示的是一个参与者。

这是一个众筹的合约，其中`newCampaign`表示的是发起一次众筹，众筹的目标账户是`beneficiary`，这是一个地址，这个地址是可以发起转账的（使用`payable`修饰）。

`numCampaigns`是全局变量，每次增加一次众筹活动，都会+1。

`campaigns`是使用`mapping`修饰的，如果直接使用`campaigns[campaignID]`就可以直接在storage存储区域中创建一个变量，后边赋值这个变量就可以了。

在`contribute`函数中，可以根据传入的`campaignID`给相应的活动捐钱。在这里，使用了`Funder({addr: msg.sender, amount: msg.value})`首先在`memory`中初始化了一个捐赠者，然后将这个捐赠者添加到了`c.funders`中，这个过程其实是将memory中的内容copy到了storage中，并不节省gas费用。

在`checkGoalReached`中，根据`campaignID`来获得筹集活动，然后检测筹集活动是否已经满足筹集的目标，如果满足的话，就直接使用`solidity`中的转账函数来给相应的合约地址进行转账。

---

从对上面的这个合约的解释中，我们可以得到两点启示。

1. 结构的初始化方式，可以通过类似`Funder({addr: msg.sender, amount: msg.value})`的方式，也可以通过类似`Campaign(beneficiary, goal, 0, 0)`的方式。
2. 结构的定义位置可以在是合约内，也可以在合约外，区别是其可见性。

### （二）数组

数组在创建的时候可以指定类型和长度，比如说`uint`类型的5个元素，可以写成`uint[5]`。

```solidity
uint[5] x;
x.push(2);
x.push(3);
x.push();
```

当然，也可以不指定数组长度，比如创建一个`uint`类型的动态长度的数组，可以写成`uint[]`。

`bytes`和`string`也是一种特殊的数组，他们都相当于`byte1[]`，但是，还是存在一些细微的差别。

- `string`不能使用索引来访问，同时也不能获得`string`的长度，比如说，我不可能使用`str[2]`获得`string`中的第三个字符。如果想获得内容或者修改某个位置的值的时候，可以直接使用`bytes(string)[2] = 'x'`来进行修改或者使用`bytes(string).length`来获得数组长度。
- `bytes`和`string`比`bytes1[]`消耗更加小，因为在`memory`中，`bytes1[]`的不同元素间要添加31个填充字节（虽然在`storage`中，这些填充字节会被压缩掉）。所以，尽可能的使用`string`和`bytes`来代替`bytes`。但是，如果你能确定字节的具体数量，可以使用`bytes1`...`bytes32`来代替，因为他们会更加节省。

### （三）映射

映射类似于Java中的HashMap。具体使用可以参考下面的例子。

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.0 <0.9.0;

contract MappingExample {
    mapping(address => uint) public balances;

    function update(uint newBalance) public {
        balances[msg.sender] = newBalance;
    }
}

contract MappingUser {
    function f() public returns (uint) {
        MappingExample m = new MappingExample();
        m.update(100);
        return m.balances(address(this));
    }
}
```

和Java中的HashMap可以嵌套一样，`mapping`也是可以嵌套的。

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.22 <0.9.0;

contract MappingExample {

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        require(_allowances[sender][msg.sender] >= amount, "ERC20: Allowance not high enough.");
        _allowances[sender][msg.sender] -= amount;
        _transfer(sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
        require(_balances[sender] >= amount, "ERC20: Not enough funds.");

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }
}
```

上面的合约是ERC20中的合约代码，其中`_allowances`就是嵌套的。首先通过第一层嵌套，获得代币拥有者对不同人的授信额度的一个mapping，然后通过第二层mapping来获得代币拥有者对某个人的授信额度。

但是，`solidity`中提供的`mapping`并不强大，对其便利非常不方便，下面定义了一个可以遍历`mapping`的通用方案，可以参考简介，或者直接引用。

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.8;

struct IndexValue { uint keyIndex; uint value; }
struct KeyFlag { uint key; bool deleted; }

struct itmap {
    mapping(uint => IndexValue) data;
    KeyFlag[] keys;
    uint size;
}

type Iterator is uint;

library IterableMapping {
    function insert(itmap storage self, uint key, uint value) internal returns (bool replaced) {
        uint keyIndex = self.data[key].keyIndex;
        self.data[key].value = value;
        if (keyIndex > 0)
            return true;
        else {
            keyIndex = self.keys.length;
            self.keys.push();
            self.data[key].keyIndex = keyIndex + 1;
            self.keys[keyIndex].key = key;
            self.size++;
            return false;
        }
    }

    function remove(itmap storage self, uint key) internal returns (bool success) {
        uint keyIndex = self.data[key].keyIndex;
        if (keyIndex == 0)
            return false;
        delete self.data[key];
        self.keys[keyIndex - 1].deleted = true;
        self.size --;
    }

    function contains(itmap storage self, uint key) internal view returns (bool) {
        return self.data[key].keyIndex > 0;
    }

    function iterateStart(itmap storage self) internal view returns (Iterator) {
        return iteratorSkipDeleted(self, 0);
    }

    function iterateValid(itmap storage self, Iterator iterator) internal view returns (bool) {
        return Iterator.unwrap(iterator) < self.keys.length;
    }

    function iterateNext(itmap storage self, Iterator iterator) internal view returns (Iterator) {
        return iteratorSkipDeleted(self, Iterator.unwrap(iterator) + 1);
    }

    function iterateGet(itmap storage self, Iterator iterator) internal view returns (uint key, uint value) {
        uint keyIndex = Iterator.unwrap(iterator);
        key = self.keys[keyIndex].key;
        value = self.data[key].value;
    }

    function iteratorSkipDeleted(itmap storage self, uint keyIndex) private view returns (Iterator) {
        while (keyIndex < self.keys.length && self.keys[keyIndex].deleted)
            keyIndex++;
        return Iterator.wrap(keyIndex);
    }
}

// How to use it
contract User {
    // Just a struct holding our data.
    itmap data;
    // Apply library functions to the data type.
    using IterableMapping for itmap;

    // Insert something
    function insert(uint k, uint v) public returns (uint size) {
        // This calls IterableMapping.insert(data, k, v)
        data.insert(k, v);
        // We can still access members of the struct,
        // but we should take care not to mess with them.
        return data.size;
    }

    // Computes the sum of all stored data.
    function sum() public view returns (uint s) {
        for (
            Iterator i = data.iterateStart();
            data.iterateValid(i);
            i = data.iterateNext(i)
        ) {
            (, uint value) = data.iterateGet(i);
            s += value;
        }
    }
```

## 五、函数

### （一）函数的返回值

函数可以有多个返回值。使用上有几个需要注意的地方：

1. 函数声明的尾部，需要增加`returns (string, uint)`，`returns`是关键字，括号里头是依次需要返回的返回内容的类型。
2. 函数方法体的末尾，需要将多个返回的内容，使用括号包裹起来，比如下面的`(fName, age)`，其返回的顺序要和函数声明的尾部`returns`后面括号后面的类型一一对应。

```solidity
pragma solidity ^0.8.13;

contract InfoContract {

   string fName;
   uint age;
   
   function setInfo(string _fName, uint _age) public {
       fName = _fName;
       age = _age;
   }
   
   function getInfo() public returns (string, uint) {
       return (fName, age);
   }   
}
```

### （二）函数访问控制符

函数访问控制符，请参考第九题和第十题。

### （三）函数修改器

使用下面的修改器可以用来检查修改记录的是，是不是用户本人。

声明一个函数修改器，首先要在相应的函数的访问修饰符后面增加修改器名称。然后再使用`modifier`申明一个修改器即可。

```solidity
contract NoteBook {
    string public record;
    address owner;

    constructor() {
        owner = msg.sender;
    }

    // 修改record的内容
    function changeRecord(string memory _record) public isOwner {
        record = _record;
    }

    // 修改器
    modifier isOwner{
        require(msg.sender == owner, "You are not the owner of this NoteBook");
        _;
    }
}
```

上述修改其中的`_;`表示执行被修饰函数的函数体的内容。

**(1)对函数参数进行校验**

```solidity
// 这个合约可以执行运算
contract Operation{
	// 除法运算
    function division(uint256 opt1, uint256 opt2) public checkZero(opt2) pure returns(uint256){
        return opt1 / opt2;
    }

    // 检查除数是否为0
    modifier checkZero(uint256 divisor) {
        require (divisor != 0, "divisor can't be 0");
        _;
    }
}
```

非常好理解，就不用解释了。

(3)参数返回后执行内容

函数修改器类似SpringBoot中的面向切面的编程。

```solidity
contract modifierOder {
    address owner;
    uint256 a;
    constructor() {
        owner = msg.sender;
    }

    function test(uint num) public checkPara(num) returns(uint256) {
        a = 10;
        return a;
    }

    // 修改a 
    modifier checkPara(uint number) {
        a = 1;
        _;
        a = 100;
    }
}
```

上面这个函数修改器，在执行完`_;`以后，还会执行`a=100`的操作，虽然返回的内容是`10`，但是最终区块链中存储的变量的值为`100`。

## 六、Web3编程

### （一）开发智能合约的集成开发环境

不论哪种方式创建合约，最终的目的就是可以编译成EVM（以太坊虚拟机）能识别的程序。这个和Java也非常相似。不论通过通过什么语言编写`Kotlin`或者是`Java`，只要最后编译出来的`.class`文件可以在符合Java虚拟机规范，就可以在Java虚拟机上运行。

以太坊虚拟机规范定义了它可以识别的程序程序文件的格式，我们在使用`solidity`语言编写合约后，可以借助多种工具生成这种文件，这类文件使用ABI（Application Binary Interface）标识。

为了将solidity转化为这种文件，我们有很多的方式来解决这个问题，第一个就是`remix`，第二个就是借助本地的`truffle`集成开发环境，类似Java中的javac。

- remix是一个网页的集成开发环境，在调试的时候非常方便，但是在进行项目开发的时候比较麻烦，尤其是和本地钱包进行互动的时候
- truffle是一个本地客户端的开发环境，虽然配置的时候比较麻烦，但是和前端项目结合起来进行开发的时候，很方便，借助于truffle项目框架，智能合约的依赖可以通过npm进行管理，非常方便。

### （二）使用Vscode开发Truffle项目

**（1）**首先安装插件`Truffle for Vs Code`，如下：

![image-20221118161332286](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221118161332286.png)

安装完成插件以后，打开命令`CTRL+SHIFT+P`，输入`Truffle`，然后随便选择一个命令，就可以激活`Truffle`组件，并弹出下面这个窗口来提示需要安装的其他组件，将他们一一点击，全部安装即可。

![image-20221118162339826](./C:/Users/bpc/Desktop/me/自我修养/2.技术/assets/image-20221118162339826.png)

> 图中`node.js`版本要求是v17.0.0以下，可以直接在后面这个链接中下载：https://nodejs.org/dist/v16.9.1/

**（2）**安装插件的依赖项

插件和相关的依赖安装完成后，重新启动`Vscode`，就可以在`Vscode`的开始页面看到下图中框出来的内容，点击这个内容就可以看到刚才安装的Truffle插件的一些主要功能。

![Welcome page](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/welcome-page.png)

**（3）**查看可以可以执行的`truffle`指令

进入后的第一项就是查看`Truffle`可以执行的指令，这些指令用来编译，发布和执行智能合约。这些指令，从`Java`的视角来看，就是使用`java -jar`启动程序，使用`javac`编译程序。

![Walkthrough](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/walkthrough.png)

**（4）**创建新的`Solidity`项目

使用`CTRL+SHIFT+P`打开VSCode的命令窗口，找到并点击`Truffle: New Solidity Project`，然后点击`Create sample project`，来创建一个例子项目，项目的目录如下图所示。

![image-20221119212540249](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221119212540249.png)

这个目录中，各个文件夹和文件的都有什么用，后面再说。只需要知道在`contracts`文件夹中放置的就是我们的智能合约。

右键点击智能合约，点击`Build Contracts`，可以编译合约。

点击`Deploy Contracts`，就可以发布合约到本地模拟的区块链网络，以太坊测试网路，或者直接可以发布的主网。

![image-20221119213634911](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221119213634911.png)

**（5）**创建本地合约网络

在发布合约的时候，会弹出框让选择希望把合约发布到哪里。如果第一次发布，可以选择第一项`Create a new network`。

![image-20221119214138223](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221119214138223.png)

然后，接着弹出框，让选择智能合约发布的位置，这个可以选择`Ganache`，这个网络类型是借助插件`Ganache`创建的本地虚拟的以太坊网络，在这个网络初始化的时候，会创建10个账户，每个账户1000个ETH。

![image-20221119214349842](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221119214349842.png)

选择智能合约发布的位置为`Ganache Service`以后，弹出框，让选择发布的类型，这个选择`Local`，表示发布到本地。

![image-20221119214704073](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221119214704073.png)

选择发布类型为`Local`以后，需要制定本地以太坊网络的监听端口，一般以太坊网路的监听端口是`8545`，当然，既然是模拟，也可以选择别的端口。

![image-20221119214836661](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221119214836661.png)

输入端口以后，点击`Enter`会弹出一个框，让输入`Ganache`模拟出来的网络到底应该是什么名字。如果做过Java，可以把这个理解为不同阶段合约发布的位置。比如，我们在`8545`创建一个虚拟网络来用于发布验证环境的智能合约，就将其命名为`验证环境`。在`8544`创建一个虚拟以太坊网络来用于发布测试环境的智能合约，将其命名为`测试环境`。最后，在`8543`创建一个开发环境，将其命名为`开发环境`。

![image-20221119214913623](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221119214913623.png)

输入完成以后，相关插件就会自动创建网络并发布合约到该网络了。

点击`Vscode`左边的`Truffle`图标，就可以在`NETWORKS`中看到已经发布的网路了。

![image-20221119222319532](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221119222319532.png)

### （三）安装浏览器钱包插件

钱包有很多，`Metamusk`是比较好用的一个，可以在`Chrome`或者`Edge`浏览器中安装。

在介绍如何使用之前，我们需要了解的是，钱包和账户的关系，钱包就相当于我们现实中的钱包，账户就相当于我们现实中的银行卡。一个钱包可以放置多个账户，同时，我们可以将一个钱包中的账户放到另一个钱包中，就像把一个钱包中的银行卡放置到另一个钱包中一样。

唯一不同的是，现实中如果银行卡丢失了，可以去银行补办，但是在网络世界中，如果账户丢失了（账户私钥），就无法再次寻找到这个账户了。

下面介绍如何在`Edge`中安装`Metamusk`。

**（1）**打开`Edge`浏览器，点击菜单按钮（右上角，三个点），然后点击扩展，然后再在扩展项中点击`Microsoft Edge`加载项。

<img src="https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120100321937.png" alt="image-20221120100321937"  />

**（2）**搜索`Metamusk`，然后点击后面的获取。

当获取完成后，会自动安装，在Edge浏览器的右上角会弹出相应的插件，并同时打开一个初始化钱包的网页。

<img src="https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120100220254.png" alt="image-20221120100220254"  />

**（3）**钱包初始化步骤

下面这个页面点击开始使用。

<img src="https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120113723253.png" alt="image-20221120113723253"  />

下面这个页面点击创建钱包。

<img src="https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120113919403.png" alt="image-20221120113919403"  />

下面这个页面按照要求输入密码，并点击同意跳转，选择创建。

<img src="https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120114059106.png" alt="image-20221120114059106"  />

下面这个页面记住助记词，这个助记词可以帮助找回钱包，如果钱包里头有账户就可以顺便帮忙找回账户。

由于这个助记词可以完全证明钱包的所有权，所以，这步一般建议使用纸笔进行物理抄录，不要截图放在电脑里头，否则，黑客很容易获得到。

下面的`shrimp fail quality bracker develop split drama can purchase flock spring inform`就是刚才创建的这个钱包的助记词，以后即使电脑爆炸了，拼接这些助记词也可以找到钱包。

<img src="https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120114618418.png" alt="image-20221120114618418"  />

钱包创建成功以后，就可以看到下面这个页面。

最上面那个红框表示的是当前的所在的以太坊网络（以太坊网络有很多种，主网，测试网，本地模拟网）。

中间的红框表示的是账户ID，这个ID是不随着上面的网络切换而切换的，换句话说，账户仅仅表示唯一的ID，创建一次就可以在不同网络中代表一个账户实体，但是不同网络中这个账户实体到底有多少钱，完全由网络来决定。

最下面的一个红框表示的是，**账户**在**以太坊主网**中包含的代币数量。

<img src="https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120114938681.png" alt="image-20221120114938681"  />

到目前为止，我们已经创建了自己的钱包，但是如果钱包在主网的话，除非别人给你转账，否则这个余额一定是0ETH。

**（4）**将钱包连接到本地以太坊网络

在前面的开发中，我们在`Vscode`中使用`Ganache`创建了以太坊的本地虚拟网络。我们可以在`Vscode`中，使用下面的方式启动本地虚拟网络，注意网络IP地址和端口是：`http://127.0.0.1:8543`。

![image-20221120120020720](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120120020720.png)

下面是控制台启动后，打印出来的信息，我截取了几个比较重要的部分。`Available Accounts`表示的是虚拟网络中创建的账户，`Private Keys`表示的是虚拟网络中上面创建的账户的私钥。`Chain Id`表示的是区块链ID，`RPC Listening on 127.0.0.1:8543`表示区块链网络监听的端口是本地的8543端口。使用这些信息，我们可以将钱包连接的本地虚拟化出来的以太坊网络，并且将有钱的账户导入到钱包。

```shell
Available Accounts
==================
(0) 0xd7D07F0a493C1b80EC93204DD574169D1C3CEb6d (1000 ETH)
(1) 0x4F607AA980e0049c53Be08389D4Dd5D88642CC14 (1000 ETH)
(2) 0x4b364104D17cFBfc55bD840ae5aD823841A275DF (1000 ETH)
(3) 0x516e6D27925dfFc8242d5Ee0455618d6e65AB0Ca (1000 ETH)
(4) 0xC8635893787024fF82C4E53b270EcA118Be74d40 (1000 ETH)
(5) 0xD3b4897c87b434B1BB506CE77D4695d8E5e0c881 (1000 ETH)
(6) 0x893FF646F800f5FD7f00112a67ad52B0FC1C2d20 (1000 ETH)
(7) 0xF72f6daaa73b1ff9D72440a1843CcE4AB37760AC (1000 ETH)
(8) 0x4b10a6c3c05eB7B4f482A6dA455226Bb07B6f63F (1000 ETH)
(9) 0x80A6798d8592734c7601C97C13A195288A7D3013 (1000 ETH)

Private Keys
==================
(0) 0xe43ca32bc2b320d6ea15e15946f6a890d94dca74f88292c51d5503d72145e417
(1) 0x7bd02a6a02e911a52792707b474f14c7cc5979293d5f8b5af7e3ea77eef79afc
(2) 0x5a59b2bfb1936de2bdaf97ab1232282c24a2f1fd73bf3b9c2c453503b872f480
(3) 0x2cc17041f787a17ed20b82301278530454e81a7de924fb9398e2a9b8177ed531
(4) 0xdbf632c02faff5d849ac15300d3a6a3c4a3c3aff5e81bdb82baf1087aaa5ee42
(5) 0xc71504f9439bf479c8dc1b3e876b7b0cc00407e9eb7f0864b569528830c28c55
(6) 0x7a772b5d1283078cfacab5cf79c9ca6bf832437de01e976d39ea604586719e9f
(7) 0xdbe8cc53645f1866a1f6028e9306f9d4c09883a90475029d6cdbfe3289d6a84a
(8) 0x08c5d3f86b0881d8f3920ef435c99e651194e9a96ebce20ee15c94e4093c3e8d
(9) 0xdaafbfcd5394ed1b4cac36910bcd183da00f82e75d4f6af540cca58a61d27d33

Chain Id
==================
1337

RPC Listening on 127.0.0.1:8543

net_listening
```

复制上面一个账户的私钥（Private Keys中的一个，比如`0xe43ca32bc2b320d6ea15e15946f6a890d94dca74f88292c51d5503d72145e417`)，然后点击钱包，然后选择导入账户，

![image-20221120133010400](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120133010400.png)

在弹出框中，选择类型为私钥，然后将复制的私钥放入输入框，点击导入。

![image-20221120133202054](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120133202054.png)

导入后，可以立即跳回到前面的主界面，如下图所示，其中账户的地址，就是可用账户（`Avaiable Accounts`）中的第一个账户`(0) 0xd7D07F0a493C1b80EC93204DD574169D1C3CEb6d (1000 ETH)`。

![image-20221120133442079](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120133442079.png)

但是，为什么余额还是`0ETH`呢？是因为我们的网络还是在主网，没有切换到本地的虚拟出来的以太坊网络。

下面，我们将一步一步来演示如何让钱包连接本地虚拟网络。

1. 点击账户，选择设置，

![image-20221120134857510](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120134857510.png)

2. 在设置中选择网络，然后将最下面的`Localhost 8545`修改成如下图所示的内容，这些内容都是在Vscode的Ganache启动的时候答应出来的内容，唯一有区别的就是要在`127.0.0.1:8543`前面加上`http`。

![image-20221120135102677](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120135102677.png)

3. 修改完后，点击保存，账户会立即切换为`localhost 8543`

![image-20221120135424939](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120135424939.png)

4. 此时，如果再回去看刚才导入的账户，就可以发现其余额为1000ETH。

![image-20221120135521387](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120135521387.png)

到此为止，我们已经学会了，在本地虚拟的网络中发布了自己的合约，同时使用`metamask`连接了本地虚拟化的网络，下一步的目标就是制作可以使用钱包来调用智能合约的前端DApp，这也是Web3开发的最后一步。

### （三）使用vue构建可以与钱包交互的项目

**（1）构建web项目**

首先，全局安装`vue-cli`

```shell
npm install -g @vue/cli
vue --version
```

然后，在刚才创建的智能合约项目中，执行下面的指令，初始化`Vue`

```shell
vue create dapp-vue
```

然后，一路点击确认执行下去，直到如下图所示，表示项目成功安装完成。



![image-20221120180538357](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120180538357.png)

使用上面的指令，可以直接启动`vue`的前端项目。此时，目录结构如下图所示，红框标出来的就是使用`vue-cli`创建的`vue`前端项目。

![image-20221120180911335](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120180911335.png)

我们在`dapp-vue/src/components/HelloWorld.vue`中，直接在`methods`对象中添加下面这个函数，然后再在`created`方法中调用`loadWeb3`即可页面加载前，让程序和浏览器中的钱包连接起来。

```solidity
    async loadWeb3() {
      if (window.ethereum) {
        window.web3 = new Web3(window.ethereum);
        await window.ethereum.enable();
      } else if (window.web3) {
        window.web3 = new Web3(window.web3.currentProvider);
      } else {
        window.alert(
          "Non-Ethereum browser detected. You should consider trying to install MetaMask!"
        );
      }
      window.web3.currentProvider.on('accountsChanged', () => {
        this.refresh();
      })
    },
```

项目中的具体结构如下：

![image-20221120181832364](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120181832364.png)

点击保存后，可以发现有下面两个错误，可以看到是在45行和48行，使用`new Web3(window.ethereum)`的时候报的。这是因为我们没有安装`web3.js`插件，这个插件可以帮助程序和浏览器中的钱包插件进行互动，从而使用钱包插件来调用其连接的以太坊网络中的智能合约。

![image-20221120181802414](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120181802414.png)

使用下面的指令可以安装`web3.js`，然后使用下面的方式在项目中引入`web3.js`。

![image-20221120191349596](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120191349596.png)

再次访问网页的时候，如果已经安装了钱包，就会弹出如下图所示的窗口，来询问使用钱包中的哪个账户与网站进行交互，当然，我们需要选择有钱的账户，也就是账户2`Account2`。

![image-20221120191229437](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120191229437.png)

下面我们再来回看一下代码：

```java
    async loadWeb3() {
      if (window.ethereum) {
        window.web3 = new Web3(window.ethereum);
        await window.ethereum.enable();
      } else if (window.web3) {
        window.web3 = new Web3(window.web3.currentProvider);
      } else {
        window.alert(
          "Non-Ethereum browser detected. You should consider trying to install MetaMask!"
        );
      }
      window.web3.currentProvider.on('accountsChanged', () => {
        this.refresh();
      })
    },
```

首先，我们一旦我们在浏览器安装了插件，浏览器中的原生对象`window`的属性`window.ethereum`和`window.web3.currentProvider`这两个属性就会被初始化，凭借这两个属性指向的代理对象，就可以与钱包进行交互了。

但是上述交互比较底层，为了方便开发者使用，我们可以借助`Web3`这个插件，继续包装钱包提供的代理对象来方便我们使用，因此，会使用`window.web3 = new Web3(window.web3.currentProvider)`这样的内容来进行包装。

最后一句比较有意思，`window.web3.currentProvider.on('accountsChanged', () => { this.refresh(); })`，其中`accountsChanged`是web3插件自己定义的，表示的是钱包账户的切换事件。这句话的意思就是，如果监听到钱包账户切换的话，调用函数`refresh()`做动态刷新。

**（2）使用web3.js调用智能合约的函数**

每次，我们发布的合约都会生成abi文件，这个文件类似于`Java`的字节码，这个字节码不仅可以发布到区块链网络中，还可以在项目中引入，来获得合约的基本信息。

比如，上面的项目中生成的`abi`文件就在根目录下的`build`文件夹中，与智能合约的名字一一对应，如下图中，左边红框标识的内容。

![image-20221120223723395](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120223723395.png)

我们在`vue`项目中，我们可以直接使用import命令来引入这个abi文件，利用这个abi文件，我们可以初始化`web3.js`中的智能合约对象。

![image-20221120223821830](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120223821830.png)

智能合约的初始化方式如下，每步的具体目的可以参看注解。

```solidity
    async loadContract() {
      // 获得网络ID，主网的ID为1，其他的是自定义的
      const networkId = await window.web3.eth.net.getId();
      console.log("networkId=" + networkId);

      // 获得该网络中的合约地址
      const address = await HelloBlockchain.networks[networkId].address;
      console.log("address=" + address);

      // 获得智能合约的abi内容
      const abi = HelloBlockchain.abi;
      console.log("abi=" + abi);

      // 使用合约的网络地址和合约的abi内容，来初始化web3中的合约对象
      this.contract = this.contract = await new window.web3.eth.Contract(abi, address);
      console.log("contract=" + this.contract);
    },
```

下面就是项目启动后，前端控制台打印出来的内容。

![image-20221120223958104](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221120223958104.png)

到此为止，合约对象已经被初始化了，下一步就是使用这个合约对象，通过钱包和以太坊的网络进行交互。

**（3）前端调用智能合约返回数据**

[web3.js - Ethereum JavaScript API — web3.js 1.0.0 documentation (web3js.readthedocs.io)](https://web3js.readthedocs.io/en/v1.7.5/)

目前来说，web3.js有两种调用合约方法的函数，一个是`send`，这个函数表示会修改合约的状态，另一个是`call`，这个函数表示不会修改合约的状态。

1. `call`函数的调用方式

```javascript
let result = myContract.methods.myMethod(123).call(
    {from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'}
	).on('transactionHash', function(hash) {}
    ).on('receipt', function(receipt) {}
    ).on('confirmation', function(confirmationNumber, receipt) {}
    ).on('error', function(error, receipt) {});
```

2. `send`函数的调用方式

```javascript
let result = myContract.methods.myMethod(123).send(
    {from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'}
	).on('transactionHash', function(hash) {}
    ).on('receipt', function(receipt) {}
    ).on('confirmation', function(confirmationNumber, receipt) {}
    ).on('error', function(error, receipt) {});
```

可以看到，除了名字不一样以外，其他都一样。

首先，为了便于测试，我们将`HelloBlockchain.sol`中的内容修改如下：

```solidity
pragma solidity >=0.4.25 <0.9.0;

contract HelloBlockchain {

    string public message;

    constructor(string memory _message) {
        message = _message;
    }

    // call this function to send a request
    function setMessage(string memory _message) public {
        message = _message;
    }

    // call this function to send a response
    function getMessage() public view returns (string memory) {
        return message;
    }
}
```

将上述合约发布以后，我们在前端项目中，再添加一个函数用来载入当前钱包的活跃账户。

因为，观察上面调用智能合约的前端函数（`send`和`call`）都是需要添加一个参数`from: 'xxx`，表示请求合约函数的账户（换句话说，就是花钱的账户）。

```solidity
    async loadAccount() {
      let accounts = await window.web3.eth.getAccounts();
      this.account = accounts[0];
      console.log(this.account);
    }
```

然后，我们就可以使用下面的两个函数来调用合约中的函数了，其中`setMessage`由于需要修改合约的状态，所以，需要使用`send`，而`getMessage`不需要修改合约的状态，所以仅仅需要使用`call`，不修改合约状态的函数都不会花费以太。

```javascript
    async setMessage() {
        console.log(this.account);
        await this.contract.methods.setMessage('Hello World!!').send({from: `${this.account}`});
    },
    async getMessage() {
        let result = await this.contract.methods.getMessage().call({from: `${this.account}`});
        alert(result);
    },
```

我们设置了两个按钮，按钮**设置信息**点击时调用`setMessage`，按钮**获得信息**点击时调用`getMessage`。

![image-20221121200657721](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221121200657721.png)

点击设置信息，钱包就会弹出如下图所示的`MetaMask Norification`，表示现在`测试账号3`正在执行合约`HelloBlockchain`的函数，发起调用的网站是：`http://localhost:8080`，函数的名称是`SET MESSAGE`。此次交易需要的燃料费是`0.0001455`，由于没有转账，所以最终的交易费用是`0.0001455`，如果点击确认，那么这笔交易就会成功，`Hello World!`就会被写入区块链中的`message`状态中。

![image-20221121201759308](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221121201759308.png)

当点击确认，将内容写入到区块链中后，再点击获取信息，就可以直接弹出如下图所示的提示框。这从侧面看出，使用`call`并不会损耗以太。

![image-20221121202015353](https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221121202015353.png)

到此为止，我们可以创建以太坊虚拟的网络，然后可以使用钱包连接虚拟的网路，也可以使用前端项目调用合约中的函数。

## 八、以太坊ERC

### （一）以太坊ERC是什么

在解释ERC之前，首先得解释一下EIP，EIP，Ethereum Improvement Proposals，以太坊改进建议，网址：https://eips.ethereum.org/，该项目是以太坊项目的一个子项目，用来收集对以太坊的改进建议，在该项目中，任何人都可以提出对以太坊的改进的建议，建议类型可以分为`Core`、`Networking`、`Interface`、`ERC`、`Meta`、`Infomational`等。

ERC，Ethereum Request for Comment，以太坊意见征求，网址：https://eips.ethereum.org/erc，这种类型的建议是针对智能合约编写规范提出的，打开网页，就可以在`Final`栏目中，找到两个最著名的智能合约编写规范`ERC-20`、`ERC-721`。

这两个规范相当于计算机网络中的`HTTP`协议，如果服务器运行`HTTP`协议，那么客户端就可以用协议规定的方式来直接访问了。但是如果服务器端定义自己的web协议，客户端就无从下手了。同理，如果智能合约遵循`ERC-20`协议，其他协议或者钱包就可以直接按照`ERC-20`的协议规范来访问该合约。否则，如果使用了自定义的协议，其他智能合约或者钱包就不兼容了，给推广落地带来了很大的阻碍。

### （二）以太坊ERC的使用案例

1. 使用**OpenZeppelin**合约模板

ERC规范只是定义了智能合约应该有哪些接口，每个接口应该具有哪些行为。相当于计算及网络中的HTTP协议，规定了有GET，POST等几种接口，以及每种接口应该具有的行为。

但在具体开发中，我们更希望直接使用类似`Tomcat`这些中间件来处理HTTP报文的收发工作，而不是通过自己手动编写代码来处理HTTP通信报文。因此，互联网的开源大牛们，就提供了一套这样的实现，他就是**OpenZeppelin**合约模板。

项目网站：

https://www.openzeppelin.com/，

Github仓库网站：

https://github.com/OpenZeppelin/openzeppelin-contracts

<img src="https://muzhi-picgo.oss-cn-beijing.aliyuncs.com/img/image-20211215100955756.png" alt="image-20211215100955756" style="zoom: 50%;" />

使用方式也非常简单，在node项目中，按照以下包：

```shell
npm install @openzeppelin/contracts
```

然后再在自己项目的合约中继承`OpenZeppelin`项目中已经实现好的基础协议即可：

```solidity
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract MyCollectible is ERC721 {
    constructor() ERC721("MyCollectible", "MCO") {
    }
}
```

## 九、智能合约函数的中的访问控制符

### （一）public、private、internal和external

上述四个关键字可以用来修饰方法或状态变量，功能相当于Java中的访问控制符，用于表示方法或者状态变量的作用域。

`public`修饰的内容可以被任何合约（当前合约、继承合约和外部合约）访问。

`private`修饰的内容可以被当前合约访问，但是不可以被继承合约或外部合约访问。

`internal`修饰的内容可以被当前合约和继承合约访问，但是不可以被继承合约或外部合约访问。

`external`修饰的内容，只能被外部合约访问。

| 关键字   | 内部合约 | 外部合约 | 继承合约 |
| -------- | -------- | -------- | -------- |
| public   | 可       | 可       | 可       |
| private  | 可       | 否       | 否       |
| internal | 可       | 否       | 可       |
| external | 否       | 可       | 否       |

`public`只有全部位置的都可以调用，`private`只有内部的可以调用，`external`只有外部的可以调用，`internal`内部和继承的都可以调用。

### （二）访问控制符的使用案例

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract Base {
    // `private`方法仅能被当前合约访问，不能被继承合约和外部合约访问
    function privateFunc() private pure returns (string memory) {
        return "private function called";
    }

    function testPrivateFunc() public pure returns (string memory) {
        return privateFunc();
    }

    // `external`方法仅能被当前合约和继承合约访问，不能被外部合约访问
    function internalFunc() internal pure returns (string memory) {
        return "internal function called";
    }

    function testInternalFunc() public pure virtual returns (string memory) {
        return internalFunc();
    }

    // `public`函数可以被当前合约、继承合约和外部合约访问
    function publicFunc() public pure returns (string memory) {
        return "public function called";
    }

    // `external`方法仅能被外部合约访问，不能被当前合约和继承合约访问
    function externalFunc() external pure returns (string memory) {
        return "external function called";
    }

    // 下面这个函数编译失败，因为`external`方法仅能被外部合约访问
    // function testExternalFunc() public pure returns (string memory) {
    //     return externalFunc();
    // }

    // 状态变量
    string private privateVar = "my private variable";
    string internal internalVar = "my internal variable";
    string public publicVar = "my public variable";
    
    // 状态变量不可以是外部的，不可以使用`external`修饰
    // string external externalVar = "my external variable";
}

contract Child is Base {
    // `private`方法仅能被当前合约访问，不可以被继承合约和外部合约访问
    // function testPrivateFunc() public pure returns (string memory) {
    //     return privateFunc();
    // }

    // `internal`方法可以被当前合约和继承合约中的方法访问，不可以被外部合约访问
    function testInternalFunc() public pure override returns (string memory) {
        return internalFunc();
    }
    
    // `external`方法仅能被外部合约访问，不能被当前合约和继承合约访问
    function testExternalFunc() public pure returns (string memory) {
        return externalFunc();
    }
}
```

## 十、constant、view和pure的区别

### （一）constant、view和pure

这三个关键字都是用来修饰函数的。

使用这三个关键字的目标就是告诉编译器函数中的逻辑不会修改状态变量。以此达到节约Gas的目的。

```solidity
function getVersion() public constant returns(uint)
function getVersion() public view returns(uint)
function getVersion() public pure returns(uint)
```

constant和view都表示，只会读取状态变量，但不会修改状态变量。由于`constant`还可以用来修饰变量。因此，在4.17版本之后，针对方法的修饰，一般使用`view`。

`pure`相对于`view`更加纯粹一些，其修饰的方法不仅不会修改状态变量，而且不会读取状态变量。

### （二）constant、view和pure的使用案例

```solidity
// SPDX-License-Identifier: GPL-3。0

pragma solidity >=0.7.0 <0.9.0;

contract constantViewPure {
    string name;
    uint public age;
    
    constructor() {
        name = "constantViewPure";
        age = 30;
    }
    
    function getAgeByView() public view returns(uint){
        // 状态变量不可以修改，只能读取
        // age += 1;
        return age;
    }
    
    function getAgeByPure() public pure returns(uint){
        // 状态变量既不可以修改，也不可以读取
        // return age;
        return 1;
    }
}
```
